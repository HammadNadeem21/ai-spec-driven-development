"use strict";(globalThis.webpackChunkfrontend_book=globalThis.webpackChunkfrontend_book||[]).push([[396],{7813(n,e,a){a.r(e),a.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"modules/isaac-ai-brain/chapter-3-nav2-humanoids","title":"Navigation with Nav2 for Humanoids","description":"Introduction to Nav2 Architecture","source":"@site/docs/modules/isaac-ai-brain/chapter-3-nav2-humanoids.md","sourceDirName":"modules/isaac-ai-brain","slug":"/modules/isaac-ai-brain/chapter-3-nav2-humanoids","permalink":"/docs/modules/isaac-ai-brain/chapter-3-nav2-humanoids","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/modules/isaac-ai-brain/chapter-3-nav2-humanoids.md","tags":[],"version":"current","frontMatter":{"title":"Navigation with Nav2 for Humanoids","sidebar_label":"Chapter 3 - Nav2 for Humanoids"},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 2 - Isaac ROS","permalink":"/docs/modules/isaac-ai-brain/chapter-2-isaac-ros"},"next":{"title":"Chapter 1: Voice-to-Action with Speech Models","permalink":"/docs/modules/vla/chapter-1-voice-to-action"}}');var s=a(4848),o=a(8453);const t={title:"Navigation with Nav2 for Humanoids",sidebar_label:"Chapter 3 - Nav2 for Humanoids"},r="Navigation with Nav2 for Humanoids",l={},c=[{value:"Introduction to Nav2 Architecture",id:"introduction-to-nav2-architecture",level:2},{value:"Core Components of Nav2",id:"core-components-of-nav2",level:3},{value:"Nav2 for Humanoid-Specific Navigation",id:"nav2-for-humanoid-specific-navigation",level:3},{value:"Nav2 Behavior Trees",id:"nav2-behavior-trees",level:2},{value:"Understanding Behavior Trees in Nav2",id:"understanding-behavior-trees-in-nav2",level:3},{value:"Key Behavior Tree Concepts",id:"key-behavior-tree-concepts",level:3},{value:"Humanoid-Specific Behavior Tree Design",id:"humanoid-specific-behavior-tree-design",level:3},{value:"Custom Humanoid Behaviors",id:"custom-humanoid-behaviors",level:3},{value:"Path Planning Adapted for Bipedal Humanoids",id:"path-planning-adapted-for-bipedal-humanoids",level:2},{value:"Humanoid Kinematic Constraints",id:"humanoid-kinematic-constraints",level:3},{value:"Costmap Adaptations",id:"costmap-adaptations",level:3},{value:"Custom Path Planners for Humanoids",id:"custom-path-planners-for-humanoids",level:3},{value:"Implementation Example",id:"implementation-example",level:3},{value:"Obstacle Avoidance for Humanoid Robots",id:"obstacle-avoidance-for-humanoid-robots",level:2},{value:"Challenges in Humanoid Obstacle Avoidance",id:"challenges-in-humanoid-obstacle-avoidance",level:3},{value:"Local Planner Adaptations",id:"local-planner-adaptations",level:3},{value:"Implementation Strategies",id:"implementation-strategies",level:3},{value:"Humanoid-Specific Obstacle Avoidance Code",id:"humanoid-specific-obstacle-avoidance-code",level:3},{value:"Adapting Nav2 Concepts for Bipedal Humanoids",id:"adapting-nav2-concepts-for-bipedal-humanoids",level:2},{value:"Configuration Files for Humanoid Navigation",id:"configuration-files-for-humanoid-navigation",level:3},{value:"Custom Plugins for Humanoid Navigation",id:"custom-plugins-for-humanoid-navigation",level:3},{value:"Launch File Configuration",id:"launch-file-configuration",level:3},{value:"Practical Exercise: Implementing Humanoid Navigation System",id:"practical-exercise-implementing-humanoid-navigation-system",level:2},{value:"Exercise Objective",id:"exercise-objective",level:3},{value:"Prerequisites",id:"prerequisites",level:3},{value:"Steps",id:"steps",level:3},{value:"Expected Results",id:"expected-results",level:3},{value:"Troubleshooting Humanoid Navigation",id:"troubleshooting-humanoid-navigation",level:2},{value:"Common Issues and Solutions",id:"common-issues-and-solutions",level:3},{value:"Performance Monitoring",id:"performance-monitoring",level:3},{value:"Summary",id:"summary",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"navigation-with-nav2-for-humanoids",children:"Navigation with Nav2 for Humanoids"})}),"\n",(0,s.jsx)(e.h2,{id:"introduction-to-nav2-architecture",children:"Introduction to Nav2 Architecture"}),"\n",(0,s.jsx)(e.p,{children:"The Navigation 2 (Nav2) stack is ROS 2's official navigation framework that provides a complete solution for robot path planning, obstacle avoidance, and navigation execution. For humanoid robots, Nav2 requires specific adaptations to handle the unique challenges of bipedal locomotion, balance requirements, and dynamic movement patterns."}),"\n",(0,s.jsx)(e.h3,{id:"core-components-of-nav2",children:"Core Components of Nav2"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Global Planner"}),": Computes optimal paths from start to goal"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Local Planner"}),": Executes short-term motion while avoiding obstacles"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Costmap 2D"}),": Maintains obstacle and cost information"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Recovery Behaviors"}),": Handles navigation failures and stuck situations"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Lifecycle Manager"}),": Controls the state transitions of navigation components"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"nav2-for-humanoid-specific-navigation",children:"Nav2 for Humanoid-Specific Navigation"}),"\n",(0,s.jsx)(e.p,{children:"Traditional Nav2 was designed primarily for wheeled robots with simple kinematic constraints. Humanoid robots require:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Balance-aware path planning"}),": Consideration of center of mass and stability"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Dynamic obstacle avoidance"}),": Adaptation to bipedal locomotion patterns"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Step-aware navigation"}),": Understanding of foot placement and stepping"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Recovery for bipedal systems"}),": Specialized recovery behaviors for humanoid robots"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"nav2-behavior-trees",children:"Nav2 Behavior Trees"}),"\n",(0,s.jsx)(e.h3,{id:"understanding-behavior-trees-in-nav2",children:"Understanding Behavior Trees in Nav2"}),"\n",(0,s.jsx)(e.p,{children:"Behavior trees provide a flexible and modular approach to organizing navigation tasks. In Nav2, behavior trees replace the monolithic navigation architecture with a more flexible, composable system."}),"\n",(0,s.jsx)(e.h3,{id:"key-behavior-tree-concepts",children:"Key Behavior Tree Concepts"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Nodes"}),": Individual actions or conditions"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Composites"}),": Combine multiple nodes (sequences, selectors)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Decorators"}),": Modify node behavior (inverter, repeater)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Conditions"}),": Boolean checks that return success/failure"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"humanoid-specific-behavior-tree-design",children:"Humanoid-Specific Behavior Tree Design"}),"\n",(0,s.jsx)(e.p,{children:"For humanoid robots, navigation behavior trees must include:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'<root main_tree_to_execute="MainTree">\n    <BehaviorTree ID="MainTree">\n        <Sequence>\n            <GoalReached/>\n            <Fallback>\n                <RecoveryNode number_of_retries="2">\n                    <PipelineSequence>\n                        <ComputePathToPose goal="{goal}" path="{path}"/>\n                        <SmoothPath input_path="{path}" output_path="{path}"/>\n                        <FollowPath path="{path}" velocity="{velocity}"/>\n                    </PipelineSequence>\n                    <ReactiveFallback>\n                        <AvoidanceController velocity="{velocity}" goal="{goal}" path="{path}"/>\n                        <IsGoalReached goal="{goal}" tolerance="0.5"/>\n                    </ReactiveFallback>\n                </RecoveryNode>\n                <ComputePathToPose goal="{goal}" path="{path}"/>\n                <SmoothPath input_path="{path}" output_path="{path}"/>\n                <FollowPath path="{path}" velocity="{velocity}"/>\n            </Fallback>\n        </Sequence>\n    </BehaviorTree>\n</root>\n'})}),"\n",(0,s.jsx)(e.h3,{id:"custom-humanoid-behaviors",children:"Custom Humanoid Behaviors"}),"\n",(0,s.jsx)(e.p,{children:"Humanoid robots need specialized behaviors:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"BalanceCheck"}),": Verify stability before movement"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"StepPlanner"}),": Plan individual steps for bipedal locomotion"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"FootPlacement"}),": Optimize foot positions for stability"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"PostureAdjust"}),": Adjust body posture during navigation"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"path-planning-adapted-for-bipedal-humanoids",children:"Path Planning Adapted for Bipedal Humanoids"}),"\n",(0,s.jsx)(e.h3,{id:"humanoid-kinematic-constraints",children:"Humanoid Kinematic Constraints"}),"\n",(0,s.jsx)(e.p,{children:"Bipedal humanoid robots have unique kinematic constraints that affect path planning:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Step Size Limits"}),": Maximum distance between consecutive steps"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Balance Envelope"}),": Maintain center of mass within support polygon"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Turning Radius"}),": Limited by leg length and hip joint constraints"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Obstacle Clearance"}),": Need for sufficient space for leg swing"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"costmap-adaptations",children:"Costmap Adaptations"}),"\n",(0,s.jsx)(e.p,{children:"The costmap for humanoid robots must consider:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Stepable Terrain"}),": Identify surfaces suitable for foot placement"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Stability Zones"}),": Mark areas where robot can maintain balance"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Obstacle Heights"}),": Consider obstacles that affect leg swing"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Ground Properties"}),": Surface type affects traction and foot placement"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"custom-path-planners-for-humanoids",children:"Custom Path Planners for Humanoids"}),"\n",(0,s.jsx)(e.p,{children:"Traditional path planners (A*, Dijkstra, etc.) need adaptation:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Step-Constrained Planning"}),": Ensure paths respect step size limits"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Balance-Aware Planning"}),": Plan paths that maintain center of mass stability"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Dynamic Planning"}),": Adapt to changing balance constraints during movement"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"implementation-example",children:"Implementation Example"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\nimport rclpy\nfrom rclpy.node import Node\nfrom nav_msgs.msg import Path\nfrom geometry_msgs.msg import PoseStamped, Point\nfrom sensor_msgs.msg import LaserScan\nfrom tf2_ros import TransformListener, Buffer\nimport math\n\nclass HumanoidPathPlanner(Node):\n    def __init__(self):\n        super().__init__(\'humanoid_path_planner\')\n\n        # Subscribe to costmap and robot pose\n        self.costmap_subscription = self.create_subscription(\n            OccupancyGrid, \'/global_costmap/costmap\',\n            self.costmap_callback, 10)\n\n        self.robot_pose_subscription = self.create_subscription(\n            PoseStamped, \'/robot_pose\',\n            self.pose_callback, 10)\n\n        # Publisher for humanoid-adapted path\n        self.path_publisher = self.create_publisher(\n            Path, \'/humanoid/global_plan\', 10)\n\n        # Humanoid-specific parameters\n        self.step_size_limit = 0.3  # meters\n        self.balance_margin = 0.1   # meters\n        self.foot_separation = 0.2  # meters\n\n    def plan_path(self, start_pose, goal_pose):\n        """Plan a path considering humanoid kinematic constraints"""\n        # Implement humanoid-specific path planning algorithm\n        # This would consider step size limits and balance constraints\n        path = Path()\n        path.header.frame_id = "map"\n\n        # Generate waypoints respecting humanoid constraints\n        current_pose = start_pose\n        while not self.at_goal(current_pose, goal_pose):\n            next_waypoint = self.calculate_next_waypoint(\n                current_pose, goal_pose)\n\n            # Verify step is within humanoid constraints\n            if self.is_valid_humanoid_step(current_pose, next_waypoint):\n                pose_stamped = PoseStamped()\n                pose_stamped.pose = next_waypoint\n                path.poses.append(pose_stamped)\n                current_pose = next_waypoint\n            else:\n                # Find alternative path\n                break\n\n        return path\n\n    def is_valid_humanoid_step(self, current_pose, next_pose):\n        """Check if step is valid for humanoid robot"""\n        # Calculate step distance\n        dx = next_pose.position.x - current_pose.position.x\n        dy = next_pose.position.y - current_pose.position.y\n        distance = math.sqrt(dx*dx + dy*dy)\n\n        # Check if within step size limit\n        if distance > self.step_size_limit:\n            return False\n\n        # Check if step maintains balance\n        # (This would involve more complex balance calculations)\n\n        return True\n\n    def calculate_next_waypoint(self, current_pose, goal_pose):\n        """Calculate next waypoint respecting humanoid constraints"""\n        # Implement humanoid-aware waypoint calculation\n        # Consider step size, balance, and obstacle avoidance\n        pass\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = HumanoidPathPlanner()\n    rclpy.spin(node)\n    node.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,s.jsx)(e.h2,{id:"obstacle-avoidance-for-humanoid-robots",children:"Obstacle Avoidance for Humanoid Robots"}),"\n",(0,s.jsx)(e.h3,{id:"challenges-in-humanoid-obstacle-avoidance",children:"Challenges in Humanoid Obstacle Avoidance"}),"\n",(0,s.jsx)(e.p,{children:"Humanoid robots face unique challenges in obstacle avoidance:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Dynamic Balance"}),": Avoiding obstacles while maintaining balance"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Foot Placement"}),": Finding safe foot placement locations"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Leg Swing Space"}),": Ensuring obstacles don't interfere with leg movement"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Turning Mechanics"}),": Different turning mechanics compared to wheeled robots"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"local-planner-adaptations",children:"Local Planner Adaptations"}),"\n",(0,s.jsx)(e.p,{children:"The local planner for humanoid robots must consider:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Step-Aware Local Planning"}),": Plan immediate steps rather than continuous motion"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Balance Preservation"}),": Maintain stability during obstacle avoidance"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Leg Swing Planning"}),": Account for leg swing trajectory during obstacle avoidance"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Reactive Behaviors"}),": Quick responses to sudden obstacles"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"implementation-strategies",children:"Implementation Strategies"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Sampling-Based Approaches"}),": Sample valid foot placements in local area"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Optimization-Based"}),": Optimize for both obstacle avoidance and balance"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Learning-Based"}),": Use machine learning to adapt to different scenarios"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"humanoid-specific-obstacle-avoidance-code",children:"Humanoid-Specific Obstacle Avoidance Code"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\nimport rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import Twist, Point\nfrom sensor_msgs.msg import LaserScan, PointCloud2\nfrom tf2_ros import TransformListener, Buffer\nimport numpy as np\n\nclass HumanoidObstacleAvoider(Node):\n    def __init__(self):\n        super().__init__(\'humanoid_obstacle_avoider\')\n\n        # Subscribe to sensor data\n        self.laser_subscription = self.create_subscription(\n            LaserScan, \'/scan\', self.laser_callback, 10)\n\n        self.robot_pose_subscription = self.create_subscription(\n            PoseStamped, \'/robot_pose\', self.pose_callback, 10)\n\n        # Publisher for velocity commands\n        self.cmd_vel_publisher = self.create_publisher(\n            Twist, \'/humanoid/cmd_vel\', 10)\n\n        # Humanoid-specific parameters\n        self.min_obstacle_distance = 0.5  # meters\n        self.step_width = 0.2            # meters (foot width)\n        self.leg_swing_radius = 0.4      # meters\n\n    def laser_callback(self, msg):\n        """Process laser scan data for obstacle avoidance"""\n        # Convert laser scan to points in robot frame\n        angles = np.linspace(msg.angle_min, msg.angle_max, len(msg.ranges))\n        ranges = np.array(msg.ranges)\n\n        # Filter valid ranges\n        valid_ranges = ranges[(ranges >= msg.range_min) & (ranges <= msg.range_max)]\n        valid_angles = angles[(ranges >= msg.range_min) & (ranges <= msg.range_max)]\n\n        # Find closest obstacles in critical directions\n        front_obstacles = self.get_front_obstacles(valid_ranges, valid_angles)\n        side_obstacles = self.get_side_obstacles(valid_ranges, valid_angles)\n\n        # Generate avoidance commands considering humanoid constraints\n        cmd_vel = self.generate_avoidance_command(front_obstacles, side_obstacles)\n\n        self.cmd_vel_publisher.publish(cmd_vel)\n\n    def get_front_obstacles(self, ranges, angles):\n        """Get obstacles in front of robot within leg swing radius"""\n        # Consider obstacles in front within leg swing range\n        front_mask = (angles > -np.pi/4) & (angles < np.pi/4)\n        front_ranges = ranges[front_mask]\n        front_angles = angles[front_mask]\n\n        # Filter obstacles within leg swing radius\n        close_mask = front_ranges < self.leg_swing_radius\n        close_ranges = front_ranges[close_mask]\n        close_angles = front_angles[close_mask]\n\n        return list(zip(close_ranges, close_angles))\n\n    def generate_avoidance_command(self, front_obstacles, side_obstacles):\n        """Generate velocity command for obstacle avoidance"""\n        cmd = Twist()\n\n        if front_obstacles:\n            # Adjust for humanoid-specific constraints\n            min_distance = min([r for r, a in front_obstacles])\n\n            if min_distance < self.min_obstacle_distance:\n                # Stop or move laterally based on humanoid capabilities\n                cmd.linear.x = 0.0\n                # Calculate lateral movement considering balance\n                cmd.linear.y = self.calculate_lateral_avoidance(front_obstacles)\n            else:\n                # Move forward with caution\n                cmd.linear.x = 0.2  # Conservative speed for humanoid\n        else:\n            # Clear path, move forward\n            cmd.linear.x = 0.4\n\n        return cmd\n\n    def calculate_lateral_avoidance(self, obstacles):\n        """Calculate lateral movement considering humanoid balance"""\n        # Implement humanoid-aware lateral avoidance\n        # Consider foot placement and balance constraints\n        pass\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = HumanoidObstacleAvoider()\n    rclpy.spin(node)\n    node.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,s.jsx)(e.h2,{id:"adapting-nav2-concepts-for-bipedal-humanoids",children:"Adapting Nav2 Concepts for Bipedal Humanoids"}),"\n",(0,s.jsx)(e.h3,{id:"configuration-files-for-humanoid-navigation",children:"Configuration Files for Humanoid Navigation"}),"\n",(0,s.jsx)(e.p,{children:"Nav2 configuration for humanoid robots requires specialized parameter files:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-yaml",children:'# humanoid_nav2_params.yaml\namcl:\n  ros__parameters:\n    use_sim_time: True\n    alpha1: 0.2\n    alpha2: 0.2\n    alpha3: 0.2\n    alpha4: 0.2\n    alpha5: 0.2\n    base_frame_id: "base_footprint"\n    beam_skip_distance: 0.5\n    beam_skip_error_threshold: 0.9\n    beam_skip_threshold: 0.3\n    do_beamskip: false\n    global_frame_id: "map"\n    lambda_short: 0.1\n    laser_likelihood_max_dist: 2.0\n    laser_max_range: 100.0\n    laser_min_range: -1.0\n    laser_model_type: "likelihood_field"\n    max_beams: 60\n    max_particles: 2000\n    min_particles: 500\n    odom_frame_id: "odom"\n    pf_err: 0.05\n    pf_z: 0.99\n    recovery_alpha_fast: 0.0\n    recovery_alpha_slow: 0.0\n    resample_interval: 1\n    robot_model_type: "nav2_amcl::DifferentialMotionModel"\n    save_pose_rate: 0.5\n    set_initial_pose: false\n    sigma_hit: 0.2\n    tf_broadcast: true\n    transform_tolerance: 1.0\n    update_min_a: 0.2\n    update_min_d: 0.2\n    z_hit: 0.5\n    z_max: 0.05\n    z_rand: 0.5\n    z_short: 0.05\n\nbt_navigator:\n  ros__parameters:\n    use_sim_time: True\n    global_frame: "map"\n    robot_base_frame: "base_footprint"\n    odom_topic: "/odom"\n    bt_loop_duration: 10\n    default_server_timeout: 20\n    enable_groot_monitoring: True\n    groot_zmq_publisher_port: 1666\n    groot_zmq_server_port: 1667\n    # Humanoid-specific behavior tree\n    plugin_lib_names: ["humanoid_navigate_to_pose"]\n\ncontroller_server:\n  ros__parameters:\n    use_sim_time: True\n    controller_frequency: 20.0\n    min_x_velocity_threshold: 0.001\n    min_y_velocity_threshold: 0.001\n    min_theta_velocity_threshold: 0.001\n    # Humanoid-specific controllers\n    progress_checker_plugin: "progress_checker"\n    goal_checker_plugin: "goal_checker"\n    controller_plugins: ["FollowPath"]\n\n    # Humanoid FollowPath controller\n    FollowPath:\n      plugin: "nav2_mppi_controller::MPPIC"\n      debug_multithreading: false\n      rate: 20.0\n      transform_tolerance: 0.1\n      look ahead distance: 0.6\n      minimum look ahead distance: 0.3\n      lateral_iterations: 3\n      longitudinal_iterations: 3\n      control_horizon: 10\n      heading_threshold: 0.2\n      # Humanoid-specific parameters\n      max_linear_speed: 0.4  # Conservative for balance\n      min_linear_speed: 0.05\n      max_angular_speed: 0.5\n      min_angular_speed: 0.1\n\nlocal_costmap:\n  ros__parameters:\n    update_frequency: 5.0\n    publish_frequency: 2.0\n    global_frame: "odom"\n    robot_base_frame: "base_footprint"\n    use_sim_time: True\n    rolling_window: true\n    width: 6\n    height: 6\n    resolution: 0.05\n    # Humanoid-specific costmap settings\n    footprint: "[ [0.2, 0.2], [0.2, -0.2], [-0.2, -0.2], [-0.2, 0.2] ]"\n    footprint_padding: 0.01\n    inflation_radius: 0.55  # Account for leg swing\n    cost_scaling_factor: 5.0\n    map_type: "costmap"\n    always_send_full_costmap: true\n\nglobal_costmap:\n  ros__parameters:\n    update_frequency: 1.0\n    publish_frequency: 1.0\n    global_frame: "map"\n    robot_base_frame: "base_footprint"\n    use_sim_time: True\n    robot_radius: 0.3  # Account for humanoid width\n    resolution: 0.05\n    track_unknown_space: true\n    # Humanoid-specific settings\n    inflation_radius: 0.7  # Larger for humanoid navigation\n    cost_scaling_factor: 3.0\n    map_type: "costmap"\n    always_send_full_costmap: true\n\nplanner_server:\n  ros__parameters:\n    expected_planner_frequency: 20.0\n    # Humanoid-specific path planner\n    planner_plugins: ["GridBased"]\n    GridBased:\n      plugin: "nav2_navfn_planner::NavfnPlanner"\n      tolerance: 0.5\n      use_astar: false\n      allow_unknown: true\n      # Humanoid-specific parameters\n      step_size_limit: 0.3  # Max step size for humanoid\n      balance_margin: 0.1   # Safety margin for balance\n'})}),"\n",(0,s.jsx)(e.h3,{id:"custom-plugins-for-humanoid-navigation",children:"Custom Plugins for Humanoid Navigation"}),"\n",(0,s.jsx)(e.p,{children:"Creating custom Nav2 plugins for humanoid-specific functionality:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"HumanoidPathPlanner"}),": Custom global planner considering step constraints"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"BalanceController"}),": Local controller maintaining stability during navigation"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"StepPlannerServer"}),": Specialized action server for humanoid navigation"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"launch-file-configuration",children:"Launch File Configuration"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:"\x3c!-- humanoid_navigation.launch.py --\x3e\nimport launch\nfrom launch_ros.actions import Node\nfrom ament_index_python.packages import get_package_share_directory\nimport os\n\ndef generate_launch_description():\n    # Get package directory\n    pkg_nav2_bringup = get_package_share_directory('nav2_bringup')\n\n    # Parameters file\n    params_file = os.path.join(\n        get_package_share_directory('your_humanoid_package'),\n        'config', 'humanoid_nav2_params.yaml'\n    )\n\n    # Navigation launch\n    navigation_launch = launch.actions.IncludeLaunchDescription(\n        launch.launch_description_sources.PythonLaunchDescriptionSource(\n            os.path.join(pkg_nav2_bringup, 'launch', 'navigation_launch.py')\n        ),\n        launch_arguments={\n            'use_sim_time': 'true',\n            'params_file': params_file\n        }.items()\n    )\n\n    # Humanoid-specific nodes\n    humanoid_controller = Node(\n        package='your_humanoid_package',\n        executable='humanoid_controller',\n        name='humanoid_controller',\n        parameters=[params_file],\n        remappings=[\n            ('/cmd_vel', '/humanoid/cmd_vel'),\n            ('/odom', '/humanoid/odom')\n        ]\n    )\n\n    return launch.LaunchDescription([\n        navigation_launch,\n        humanoid_controller\n    ])\n"})}),"\n",(0,s.jsx)(e.h2,{id:"practical-exercise-implementing-humanoid-navigation-system",children:"Practical Exercise: Implementing Humanoid Navigation System"}),"\n",(0,s.jsx)(e.h3,{id:"exercise-objective",children:"Exercise Objective"}),"\n",(0,s.jsx)(e.p,{children:"Create a complete Nav2-based navigation system adapted for bipedal humanoid constraints, implementing custom path planning and obstacle avoidance."}),"\n",(0,s.jsx)(e.h3,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"ROS 2 Humble with Nav2 installed"}),"\n",(0,s.jsx)(e.li,{children:"Isaac ROS perception pipeline running"}),"\n",(0,s.jsx)(e.li,{children:"Simulated or real humanoid robot"}),"\n",(0,s.jsx)(e.li,{children:"Sensor data (LiDAR, IMU, cameras)"}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"steps",children:"Steps"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Configuration Setup"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Create humanoid-specific Nav2 parameter files"}),"\n",(0,s.jsx)(e.li,{children:"Configure costmap for humanoid dimensions"}),"\n",(0,s.jsx)(e.li,{children:"Set up behavior tree for humanoid navigation"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Custom Plugin Development"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Implement humanoid-aware path planner"}),"\n",(0,s.jsx)(e.li,{children:"Create balance-preserving local controller"}),"\n",(0,s.jsx)(e.li,{children:"Develop step-aware obstacle avoidance"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Integration Testing"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Launch complete navigation stack"}),"\n",(0,s.jsx)(e.li,{children:"Test with simulated humanoid robot"}),"\n",(0,s.jsx)(e.li,{children:"Validate path planning and obstacle avoidance"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Performance Validation"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Measure navigation success rates"}),"\n",(0,s.jsx)(e.li,{children:"Verify balance preservation during navigation"}),"\n",(0,s.jsx)(e.li,{children:"Test recovery behaviors for humanoid-specific failures"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"expected-results",children:"Expected Results"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Complete Nav2 navigation system adapted for humanoid robots"}),"\n",(0,s.jsx)(e.li,{children:"Successful path planning considering step constraints"}),"\n",(0,s.jsx)(e.li,{children:"Stable obstacle avoidance maintaining balance"}),"\n",(0,s.jsx)(e.li,{children:"High success rate in navigation tasks"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"troubleshooting-humanoid-navigation",children:"Troubleshooting Humanoid Navigation"}),"\n",(0,s.jsx)(e.h3,{id:"common-issues-and-solutions",children:"Common Issues and Solutions"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Balance Loss During Navigation"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Problem: Robot loses balance while following paths"}),"\n",(0,s.jsx)(e.li,{children:"Solution: Adjust path smoothing and velocity profiles"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Step Planning Failures"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Problem: Unable to find valid foot placements"}),"\n",(0,s.jsx)(e.li,{children:"Solution: Increase costmap resolution and adjust inflation"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Oscillation in Local Planning"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Problem: Robot oscillates near obstacles"}),"\n",(0,s.jsx)(e.li,{children:"Solution: Tune local planner parameters and increase hysteresis"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Recovery Behavior Failures"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Problem: Recovery behaviors don't work for humanoid"}),"\n",(0,s.jsx)(e.li,{children:"Solution: Implement humanoid-specific recovery actions"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"performance-monitoring",children:"Performance Monitoring"}),"\n",(0,s.jsx)(e.p,{children:"Monitor these key metrics for humanoid navigation:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Balance maintenance"}),": Percentage of time robot maintains stability"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Path following accuracy"}),": Deviation from planned path"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Obstacle avoidance success"}),": Successful avoidance rate"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Navigation completion"}),": Goal reaching success rate"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Computation time"}),": Real-time performance of navigation stack"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(e.p,{children:"Navigation for humanoid robots requires significant adaptations to the standard Nav2 framework to account for bipedal locomotion, balance constraints, and unique kinematic properties. By implementing humanoid-aware path planning, balance-preserving local control, and step-aware obstacle avoidance, we can create robust navigation systems for humanoid robots."}),"\n",(0,s.jsx)(e.p,{children:"The combination of Isaac Sim for training, Isaac ROS for perception, and adapted Nav2 for navigation creates a complete AI brain for humanoid robots, enabling them to perceive, plan, and navigate in complex environments while maintaining stability and safety."}),"\n",(0,s.jsx)(e.p,{children:"This completes the three-chapter module on the NVIDIA Isaac AI Robot Brain, providing comprehensive coverage of simulation, perception, and navigation for humanoid robots using NVIDIA's Isaac ecosystem."})]})}function h(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}},8453(n,e,a){a.d(e,{R:()=>t,x:()=>r});var i=a(6540);const s={},o=i.createContext(s);function t(n){const e=i.useContext(o);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:t(n.components),i.createElement(o.Provider,{value:e},n.children)}}}]);